Broom memoryLimit: 1024 * 1024 * 1024 * 8.
Broom autoAlloc: True.

import main: \*.
import
  Library/Test: 'describe'
.

describe Lexer do: {:it:let
  it exists do: {
    { Lexer. } should not raiseError: String.
  }.
  let[Reflect thisContext] lexer { Lexer }.

  let[Reflect thisContext] collist {
    File new: 'collation', read split: '\n',
    fmap: {:x ^x split: ' ' max: 1.}
  }.

  it ~ 'is not Nil' do: {
    lexer should not = Nil.
    lexer collate: collist.
  }.

  it can lex simple persian sentences do: {
    (lexer split: 'کلمات فارسی')
      should = ['کلمات', 'فارسی'].
  }.

  it can lex persian sentences with half-width spaces do: {
    (lexer split: 'این جمله (خیلی) پیچیده نیست!!!')
      should = (['این' ,'جمله' ,'(' ,'خیلی' ,')' ,'پیچیده' ,'نیست', '!', '!', '!']).
  }.
  it can lex arbitrary persian text do: {
    # Pen writeln:
      (lexer split: 'می‌شدید اون پارسر ترم رو دیدی؟ یه تیکه هست مچ رو درست پیدا میکنه ولی توشو خالی میده')
        should = [
          'می‌شدید', 'اون', 'پارسر',
          'ترم', 'رو', 'دیدی', '؟', 'یه',
          'تیکه', 'هست', 'مچ', 'رو', 'درست',
          'پیدا', 'میکنه', 'ولی', 'توشو',
          'خالی', 'میده'
        ].
      # .
  }.
}.

#:language XFrozen

describe TokenAnalyser do: {:it:let
  it exists do: {
    { TokenAnalyser. } should not raiseError: String.
  }.

  let[Reflect thisContext] lexer { Lexer }.
  let[Reflect thisContext] analyser { TokenAnalyser with: lexer }.
  let[Reflect thisContext] glblctx { Reflect thisContext }.
  let[Reflect thisContext] consolidateAll { Nil }.
  let[Reflect thisContext] appearsIn { Nil }.
  let[Reflect thisContext] allTargetTexts { Nil }.

  it can tokenise do: {:thisTest
    allTargetTexts is (
      File
        list: 'samples',
        filter: (\:_:descr (descr @ 'file' startsWith: 'sample')),
        from: 0 length: 100,
        fmap!: \:descr [(File new: 'out/' + (descr @ 'file')), (File new: 'samples/' + (descr @ 'file'), read)]
    ).
    thisTest tests: 'Tokeniser'.
    thisTest progressesUpTo: allTargetTexts count.

    var res is analyser
      SWconsolidate: allTargetTexts
      pre: {:i thisTest progress: i. }
      post: { thisTest show. }.

    consolidateAll is res @ 0.
    appearsIn is res @ 1.
  }.

  it can calculate RSD do: {:thisTest
    thisTest tests: 'Relative Standard Deviation'.
    thisTest progressesUpTo: consolidateAll count.
    var rsd is analyser
      calculateRSD: consolidateAll
      withMap: appearsIn
      pre: {:i thisTest progress: i. }
      post: { thisTest show. }
    .
    # RSD for each token determines
    # how common it is to the whole dataset
    let[glblctx] rsd { rsd }.

    # dump rsd for inspection
    var fs is File new: 'rsd', open: 'w+'.
    rsd each: {:k:v
      fs write: '${{k}}$\t${{v}}$\n'.
    }.
    fs close.
  }.

  it can detect stopwords do: {:thisTest
    thisTest tests: 'Stopword detection'.
    var kfs is File new: 'gen-stopwords', open: 'w+'.
    kfs write: '%:L' % ['\n', (rsd fmap: \:x [rsd @ x, x], values sort: {:x:y ^x head > y head.}, take: 300, fmap!: \:x x last)].
    kfs close.
  }.
}.
